<!doctype html>
<html lang="pt-br" data-theme="light">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>AppBase • 5 Horas</title>
  <link rel="stylesheet" href="styles/core.css">
  <link rel="stylesheet" href="styles/tokens.css">
  <link rel="stylesheet" href="styles/themes/light.css">
  <link rel="stylesheet" href="styles/themes/dark.css">
  <link rel="stylesheet" href="styles/utilities.css">
  <link rel="stylesheet" href="styles/components.css">
  <link rel="stylesheet" href="styles/miniapp-scope.css">
  <style>body{background:var(--ac-bg);color:var(--ac-ink);font-family:var(--ac-font-sans)}</style>
</head>
<body class="u-col app-body">
  <header class="u-row app-header">
    <div class="u-row app-header__branding">
      <strong data-i18n="app.header.title">5 Horas — AppBase</strong>
    </div>
    <div class="u-row app-header__actions">
      <select id="locale">
        <option value="pt-br">PT-BR</option>
        <option value="en-us">EN</option>
        <option value="es-419">ES</option>
      </select>
      <button class="c-btn" id="toggle-theme" data-i18n="app.header.themeToggle">Tema</button>
    </div>
  </header>

  <main class="u-row app-shell">
    <aside class="u-card app-shell__rail">
      <h3 style="margin-top:0" data-i18n="app.catalog.title">MiniApps</h3>
      <div id="catalog" class="app-catalog"></div>
    </aside>
    <section id="viewport" class="u-col u-gap-4 app-shell__content">
      <div class="u-card">
        <h2 data-i18n="app.viewport.welcome.title">Bem-vindo</h2>
        <p class="u-muted" data-i18n="app.viewport.welcome.subtitle">Abra o MiniApp Gestor de Tarefas para testar.</p>
      </div>
    </section>
  </main>

  <footer id="app-footer" class="app-footer">
    <button type="button" id="version-trigger" class="app-footer__button" aria-haspopup="dialog" aria-controls="version-modal"></button>
  </footer>

  <div id="version-overlay" class="status-overlay" hidden>
    <div id="version-modal" class="status-modal" role="dialog" aria-modal="true" aria-labelledby="status-modal-title">
      <button type="button" id="version-modal-close" class="status-modal__close" aria-label="Fechar">×</button>
      <h2 id="status-modal-title" data-i18n="app.statusModal.title">Status do sistema</h2>
      <dl class="status-modal__details">
        <div class="status-modal__row">
          <dt data-i18n="app.statusModal.fields.version">Versão</dt>
          <dd id="status-modal-version"></dd>
        </div>
        <div class="status-modal__row">
          <dt data-i18n="app.statusModal.fields.date">Data</dt>
          <dd id="status-modal-date"></dd>
        </div>
        <div class="status-modal__row">
          <dt data-i18n="app.statusModal.fields.description">Descrição</dt>
          <dd id="status-modal-description"></dd>
        </div>
        <div class="status-modal__row">
          <dt data-i18n="app.statusModal.fields.status">Status</dt>
          <dd id="status-modal-status"></dd>
        </div>
      </dl>
    </div>
  </div>

  <script type="module">
    import { setTheme } from './scripts/theme.js';
    import { i18n, loadBaseI18n, loadMiniSnippet } from './scripts/i18n-loader.js';
    import { initVersionStatus, refreshVersionTranslations } from './scripts/version-status.js';
    import { fetchMiniappsCatalog } from './scripts/data-sources.js';
    import { getSupabaseClient, ensureAnonymousSession } from './scripts/supabaseClient.js';
    import { projectStore } from './scripts/projectStore.js';

    const viewport = document.getElementById('viewport');
    const catalog = document.getElementById('catalog');
    const baseTitle = document.title;
    const TASK_CACHE_PREFIX = 'appbase.tasks.';
    const TASK_STATUS_VALUES = ['pending', 'in_progress', 'done'];

    const ensureRelativePath = (path) => {
      if (typeof path !== 'string' || path.length === 0) return path ?? '';
      return path.startsWith('../') ? path : `../${path}`;
    };

    function getTaskCacheKey(miniappId){
      return `${TASK_CACHE_PREFIX}${miniappId}`;
    }

    function loadCachedTasks(miniappId){
      const cached = projectStore.get(getTaskCacheKey(miniappId), []);
      return Array.isArray(cached) ? cached : [];
    }

    function persistCachedTasks(miniappId, tasks){
      projectStore.set(getTaskCacheKey(miniappId), tasks);
    }

    function normalizeStatus(value){
      if (!value) return 'pending';
      const normalized = value.toLowerCase().replace(/\s+/g, '_');
      return TASK_STATUS_VALUES.includes(normalized) ? normalized : 'pending';
    }

    // Estado
    const catalogResult = await fetchMiniappsCatalog();
    const miniapps = catalogResult.items.map(miniapp => {
      const normalizedSnippetPath = typeof miniapp.snippetPath === 'string'
        ? miniapp.snippetPath
        : (typeof miniapp.snippetSource === 'string' ? miniapp.snippetSource : null);
      return {
        ...miniapp,
        entry: ensureRelativePath(miniapp.entry),
        manifest: ensureRelativePath(miniapp.manifest),
        snippetSource: typeof miniapp.snippetSource === 'string' ? ensureRelativePath(miniapp.snippetSource) : miniapp.snippetSource,
        snippetPath: normalizedSnippetPath ? ensureRelativePath(normalizedSnippetPath) : null
      };
    });
    let activeMiniapp = null;

    // i18n base
    await loadBaseI18n('pt-br');
    await initVersionStatus();
    renderCatalog();
    applyBaseTranslations();

    // UI catálogo
    function renderCatalog(){
      catalog.innerHTML = '';
      if (!miniapps.length) {
        const empty = document.createElement('p');
        empty.className = 'u-text-muted';
        empty.textContent = 'Catálogo indisponível no momento.';
        catalog.appendChild(empty);
        return;
      }

      miniapps.forEach(m => {
        const btn = document.createElement('button');
        btn.className = 'c-btn c-btn--primary';
        btn.textContent = m.name;
        const labelKey = `app.catalog.items.${m.id}`;
        btn.dataset.i18n = labelKey;
        btn.dataset.i18nFallback = m.displayNames?.['pt-br'] ?? m.name;
        btn.onclick = async () => {
          await openMiniapp(m);
        };
        catalog.appendChild(btn);
      });
    }

    async function openMiniapp(miniapp){
      activeMiniapp = miniapp;
      if (miniapp.snippetSource) {
        await loadMiniSnippet(miniapp.snippetSource);
      } else if (miniapp.snippetPath) {
        await loadMiniSnippet(miniapp.snippetPath);
      }
      const html = await (await fetch(miniapp.entry)).text();
      viewport.innerHTML = html;
      // i18n placeholders simples: {{ t('key') }}
      viewport.innerHTML = viewport.innerHTML.replace(/\{\{\s*t\('([^']+)'\)\s*\}\}/g, (_, key) => i18n.t(key));
      await attachTaskTableHandlers(miniapp);
    }

    function translateKey(key, fallback){
      const translated = i18n.t(key);
      return translated === key ? fallback : translated;
    }

    function applyBaseTranslations(){
      document.documentElement.lang = i18n.locale;
      document.title = translateKey('app.meta.title', baseTitle);
      const localeSelect = document.getElementById('locale');
      localeSelect.value = i18n.locale;
      document.querySelectorAll('[data-i18n]').forEach(el => {
        const key = el.getAttribute('data-i18n');
        const fallback = el.dataset.i18nFallback ?? el.textContent;
        if (!el.dataset.i18nFallback && fallback) {
          el.dataset.i18nFallback = fallback;
        }
        const value = translateKey(key, fallback);
        if (el instanceof HTMLInputElement) {
          el.value = value;
        } else {
          el.textContent = value;
        }
      });
      refreshVersionTranslations(i18n);
    }

    // Troca de idioma
    const localeSelect = document.getElementById('locale');
    localeSelect.addEventListener('change', async (e) => {
      await loadBaseI18n(e.target.value);
      applyBaseTranslations();
      // Re-render mínimo: recarrega o MiniApp aberto
      if (activeMiniapp) {
        await openMiniapp(activeMiniapp);
      }
    });

    // Tema
    document.getElementById('toggle-theme').onclick = () => {
      const next = document.documentElement.getAttribute('data-theme') === 'light' ? 'dark' : 'light';
      setTheme(next);
    };

    // Funções do MiniApp Gestor de Tarefas (handlers simples)
    async function attachTaskTableHandlers(miniapp){
      const addBtn = viewport.querySelector('[data-action="add-row"]');
      const tbody = viewport.querySelector('#gt-rows');
      if (!addBtn || !tbody || !miniapp?.id) {
        return;
      }

      const miniappId = miniapp.id;
      let tasks = [];
      let session = null;
      const supabase = getSupabaseClient();

      addBtn.disabled = true;

      function renderRows(list){
        tbody.innerHTML = '';
        list.forEach(task => {
          const row = createRow(task);
          tbody.appendChild(row);
        });
      }

      function getCell(row, field){
        return row.querySelector(`[data-field="${field}"]`);
      }

      async function ensureSession(){
        if (!supabase) return null;
        if (session) return session;
        session = await ensureAnonymousSession();
        if (!session) {
          console.warn('[tasks] Sessão anônima indisponível');
        }
        return session;
      }

      async function hydrateTasks(){
        if (!supabase) {
          tasks = loadCachedTasks(miniappId);
          renderRows(tasks);
          return;
        }
        const activeSession = await ensureSession();
        if (!activeSession) {
          tasks = loadCachedTasks(miniappId);
          renderRows(tasks);
          return;
        }
        try {
          const { data, error } = await supabase
            .from('task_items')
            .select('id,title,status,created_at')
            .eq('miniapp_id', miniappId)
            .order('created_at', { ascending: true });
          if (error) {
            throw error;
          }
          tasks = Array.isArray(data)
            ? data.map(row => ({ id: row.id, title: row.title, status: row.status }))
            : [];
          persistCachedTasks(miniappId, tasks);
          renderRows(tasks);
        } catch (error) {
          console.warn('[tasks] Falha ao carregar tarefas', error);
          tasks = loadCachedTasks(miniappId);
          renderRows(tasks);
        }
      }

      async function persistRow(row){
        if (row.dataset.syncing === 'true') return;
        const titleCell = getCell(row, 'title');
        const statusCell = getCell(row, 'status');
        const titleValue = (titleCell?.textContent ?? '').trim();
        const statusValue = normalizeStatus(statusCell?.textContent ?? '');

        if (!titleValue) {
          const existing = tasks.find(item => item.id === row.dataset.taskId);
          if (existing) {
            if (titleCell) titleCell.textContent = existing.title;
            if (statusCell) statusCell.textContent = existing.status;
          } else {
            row.remove();
          }
          return;
        }

        if (!supabase) {
          const id = row.dataset.taskId;
          if (!id) {
            row.dataset.taskId = `local-${Date.now()}`;
          }
          const existingIndex = tasks.findIndex(item => item.id === row.dataset.taskId);
          const payload = { id: row.dataset.taskId, title: titleValue, status: statusValue };
          if (existingIndex >= 0) {
            tasks[existingIndex] = payload;
          } else {
            tasks.push(payload);
          }
          persistCachedTasks(miniappId, tasks);
          return;
        }

        const activeSession = await ensureSession();
        if (!activeSession) {
          return;
        }

        row.dataset.syncing = 'true';
        try {
          if (row.dataset.taskId) {
            const { error } = await supabase
              .from('task_items')
              .update({ title: titleValue, status: statusValue })
              .eq('id', row.dataset.taskId);
            if (error) {
              throw error;
            }
            const index = tasks.findIndex(item => item.id === row.dataset.taskId);
            if (index >= 0) {
              tasks[index] = { ...tasks[index], title: titleValue, status: statusValue };
            }
          } else {
            const { data, error } = await supabase
              .from('task_items')
              .insert({ miniapp_id: miniappId, title: titleValue, status: statusValue })
              .select('id,title,status')
              .single();
            if (error) {
              throw error;
            }
            row.dataset.taskId = data.id;
            tasks.push({ id: data.id, title: data.title, status: data.status });
          }
          persistCachedTasks(miniappId, tasks);
        } catch (error) {
          console.warn('[tasks] Falha ao sincronizar linha', error);
          row.classList.add('u-border-danger');
        } finally {
          row.dataset.syncing = 'false';
        }
      }

      async function removeRow(row){
        const id = row.dataset.taskId;
        if (!id) {
          row.remove();
          return;
        }

        if (!supabase) {
          row.remove();
          tasks = tasks.filter(item => item.id !== id);
          persistCachedTasks(miniappId, tasks);
          return;
        }

        const activeSession = await ensureSession();
        if (!activeSession) {
          return;
        }

        try {
          const { error } = await supabase
            .from('task_items')
            .delete()
            .eq('id', id);
          if (error) {
            throw error;
          }
          row.remove();
          tasks = tasks.filter(item => item.id !== id);
          persistCachedTasks(miniappId, tasks);
        } catch (error) {
          console.warn('[tasks] Falha ao remover linha', error);
        }
      }

      function createRow(task){
        const tr = document.createElement('tr');
        if (task?.id) {
          tr.dataset.taskId = task.id;
        }

        const titleCell = document.createElement('td');
        titleCell.contentEditable = 'true';
        titleCell.dataset.field = 'title';
        titleCell.textContent = task?.title ?? '';

        const statusCell = document.createElement('td');
        statusCell.contentEditable = 'true';
        statusCell.dataset.field = 'status';
        statusCell.textContent = task?.status ?? 'pending';

        const actionsCell = document.createElement('td');
        const deleteBtn = document.createElement('button');
        deleteBtn.className = 'c-btn';
        deleteBtn.dataset.action = 'delete';
        deleteBtn.textContent = i18n.t('miniapps.gestor-de-tarefas.tabela.excluir');
        actionsCell.appendChild(deleteBtn);

        tr.appendChild(titleCell);
        tr.appendChild(statusCell);
        tr.appendChild(actionsCell);

        const syncRow = () => { persistRow(tr); };
        titleCell.addEventListener('blur', syncRow);
        statusCell.addEventListener('blur', syncRow);
        deleteBtn.addEventListener('click', () => removeRow(tr));

        return tr;
      }

      addBtn.onclick = () => {
        const row = createRow({ title: '', status: 'pending' });
        tbody.prepend(row);
        const titleCell = getCell(row, 'title');
        titleCell?.focus();
      };

      await hydrateTasks();
      addBtn.disabled = false;
    }
  </script>
</body>
</html>
