<!doctype html>
<html lang="pt-br" data-theme="light">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>AppBase • 5 Horas</title>
  <link rel="stylesheet" href="styles/core.css">
  <link rel="stylesheet" href="styles/tokens.css">
  <link rel="stylesheet" href="styles/themes/light.css">
  <link rel="stylesheet" href="styles/themes/dark.css">
  <link rel="stylesheet" href="styles/utilities.css">
  <link rel="stylesheet" href="styles/components.css">
  <link rel="stylesheet" href="styles/miniapp-scope.css">
  <style>body{background:var(--ac-bg);color:var(--ac-ink);font-family:var(--ac-font-sans)}</style>
</head>
<body class="u-col app-body">
  <header class="u-row app-header">
    <div class="u-row app-header__branding">
      <strong data-i18n="app.header.title">5 Horas — AppBase</strong>
    </div>
    <div class="u-row app-header__actions">
      <select id="locale">
        <option value="pt-br">PT-BR</option>
        <option value="en-us">EN</option>
        <option value="es-419">ES</option>
      </select>
      <button class="c-btn" id="toggle-theme" data-i18n="app.header.themeToggle">Tema</button>
    </div>
  </header>

  <main class="u-row app-shell">
    <aside class="u-card app-shell__rail">
      <h3 style="margin-top:0" data-i18n="app.catalog.title">MiniApps</h3>
      <div id="catalog" class="app-catalog"></div>
    </aside>
    <section id="viewport" class="u-col u-gap-4 app-shell__content">
      <div class="u-card">
        <h2 data-i18n="app.viewport.welcome.title">Bem-vindo</h2>
        <p class="u-muted" data-i18n="app.viewport.welcome.subtitle">Abra o MiniApp Gestor de Tarefas para testar.</p>
      </div>
    </section>
  </main>

  <footer id="app-footer" class="app-footer">
    <button type="button" id="version-trigger" class="app-footer__button" aria-haspopup="dialog" aria-controls="version-modal"></button>
  </footer>

  <div id="version-overlay" class="status-overlay" hidden>
    <div id="version-modal" class="status-modal" role="dialog" aria-modal="true" aria-labelledby="status-modal-title">
      <button type="button" id="version-modal-close" class="status-modal__close" aria-label="Fechar">×</button>
      <h2 id="status-modal-title" data-i18n="app.statusModal.title">Status do sistema</h2>
      <dl class="status-modal__details">
        <div class="status-modal__row">
          <dt data-i18n="app.statusModal.fields.version">Versão</dt>
          <dd id="status-modal-version"></dd>
        </div>
        <div class="status-modal__row">
          <dt data-i18n="app.statusModal.fields.date">Data</dt>
          <dd id="status-modal-date"></dd>
        </div>
        <div class="status-modal__row">
          <dt data-i18n="app.statusModal.fields.description">Descrição</dt>
          <dd id="status-modal-description"></dd>
        </div>
        <div class="status-modal__row">
          <dt data-i18n="app.statusModal.fields.status">Status</dt>
          <dd id="status-modal-status"></dd>
        </div>
      </dl>
    </div>
  </div>

  <script type="module">
    import { setTheme } from './scripts/theme.js';
    import { i18n, loadBaseI18n, loadMiniSnippet } from './scripts/i18n-loader.js';
    import { initVersionStatus, refreshVersionTranslations } from './scripts/version-status.js';
    import { fetchMiniappsCatalog } from './scripts/data-sources.js';
    import { getSupabaseClient } from './scripts/supabaseClient.js';
    import { projectStore } from './scripts/projectStore.js';

    const viewport = document.getElementById('viewport');
    const catalog = document.getElementById('catalog');
    const baseTitle = document.title;
    const TASK_CACHE_PREFIX = 'appbase.tasks.';
    const TASK_STATUS_VALUES = ['pending', 'in_progress', 'done'];

    const ensureRelativePath = (path) => {
      if (typeof path !== 'string' || path.length === 0) return path ?? '';
      return path.startsWith('../') ? path : `../${path}`;
    };

    function getTaskCacheKey(miniappId){
      return `${TASK_CACHE_PREFIX}${miniappId}`;
    }

    function loadCachedTasks(miniappId){
      const cached = projectStore.get(getTaskCacheKey(miniappId), []);
      return Array.isArray(cached) ? cached : [];
    }

    function persistCachedTasks(miniappId, tasks){
      projectStore.set(getTaskCacheKey(miniappId), tasks);
    }

    function normalizeStatus(value){
      if (!value) return 'pending';
      const normalized = value.toLowerCase().replace(/\s+/g, '_');
      return TASK_STATUS_VALUES.includes(normalized) ? normalized : 'pending';
    }

    // Estado
    const catalogResult = await fetchMiniappsCatalog();
    const miniapps = catalogResult.items.map(miniapp => {
      const normalizedSnippetPath = typeof miniapp.snippetPath === 'string'
        ? miniapp.snippetPath
        : (typeof miniapp.snippetSource === 'string' ? miniapp.snippetSource : null);
      return {
        ...miniapp,
        entry: ensureRelativePath(miniapp.entry),
        manifest: ensureRelativePath(miniapp.manifest),
        snippetSource: typeof miniapp.snippetSource === 'string' ? ensureRelativePath(miniapp.snippetSource) : miniapp.snippetSource,
        snippetPath: normalizedSnippetPath ? ensureRelativePath(normalizedSnippetPath) : null
      };
    });
    let activeMiniapp = null;

    // i18n base
    await loadBaseI18n('pt-br');
    await initVersionStatus();
    renderCatalog();
    applyBaseTranslations();

    // UI catálogo
    function renderCatalog(){
      catalog.innerHTML = '';
      if (!miniapps.length) {
        const empty = document.createElement('p');
        empty.className = 'u-text-muted';
        empty.textContent = 'Catálogo indisponível no momento.';
        catalog.appendChild(empty);
        return;
      }

      miniapps.forEach(m => {
        const btn = document.createElement('button');
        btn.className = 'c-btn c-btn--primary';
        btn.textContent = m.name;
        const labelKey = `app.catalog.items.${m.id}`;
        btn.dataset.i18n = labelKey;
        btn.dataset.i18nFallback = m.displayNames?.['pt-br'] ?? m.name;
        btn.onclick = async () => {
          await openMiniapp(m);
        };
        catalog.appendChild(btn);
      });
    }

    async function openMiniapp(miniapp){
      activeMiniapp = miniapp;
      if (miniapp.snippetSource) {
        await loadMiniSnippet(miniapp.snippetSource);
      } else if (miniapp.snippetPath) {
        await loadMiniSnippet(miniapp.snippetPath);
      }
      const html = await (await fetch(miniapp.entry)).text();
      viewport.innerHTML = html;
      // i18n placeholders simples: {{ t('key') }}
      viewport.innerHTML = viewport.innerHTML.replace(/\{\{\s*t\('([^']+)'\)\s*\}\}/g, (_, key) => i18n.t(key));
      await attachTaskTableHandlers(miniapp);
    }

    function translateKey(key, fallback){
      const translated = i18n.t(key);
      return translated === key ? fallback : translated;
    }

    function applyBaseTranslations(){
      document.documentElement.lang = i18n.locale;
      document.title = translateKey('app.meta.title', baseTitle);
      const localeSelect = document.getElementById('locale');
      localeSelect.value = i18n.locale;
      document.querySelectorAll('[data-i18n]').forEach(el => {
        const key = el.getAttribute('data-i18n');
        const fallback = el.dataset.i18nFallback ?? el.textContent;
        if (!el.dataset.i18nFallback && fallback) {
          el.dataset.i18nFallback = fallback;
        }
        const value = translateKey(key, fallback);
        if (el instanceof HTMLInputElement) {
          el.value = value;
        } else {
          el.textContent = value;
        }
      });
      refreshVersionTranslations(i18n);
    }

    // Troca de idioma
    const localeSelect = document.getElementById('locale');
    localeSelect.addEventListener('change', async (e) => {
      await loadBaseI18n(e.target.value);
      applyBaseTranslations();
      // Re-render mínimo: recarrega o MiniApp aberto
      if (activeMiniapp) {
        await openMiniapp(activeMiniapp);
      }
    });

    // Tema
    document.getElementById('toggle-theme').onclick = () => {
      const next = document.documentElement.getAttribute('data-theme') === 'light' ? 'dark' : 'light';
      setTheme(next);
    };

    // Funções do MiniApp Gestor de Tarefas (handlers simples)
    async function attachTaskTableHandlers(miniapp){
      const addBtn = viewport.querySelector('[data-action="add-row"]');
      const tbody = viewport.querySelector('#gt-rows');
      if (!addBtn || !tbody || !miniapp?.id) {
        return;
      }

      const miniappId = miniapp.id;
      let tasks = [];
      let activeSession = null;
      let realtimeChannel = null;
      const supabase = getSupabaseClient();
      const isSupabaseAvailable = Boolean(supabase);

      addBtn.disabled = true;

      const header = viewport.querySelector('header');
      const authNotice = document.createElement('p');
      authNotice.className = 'u-muted';
      authNotice.dataset.role = 'auth-alert';
      authNotice.hidden = true;
      header?.appendChild(authNotice);

      const mapRow = (row) => {
        if (!row) return null;
        return {
          id: row.id,
          miniappId: row.miniapp_id ?? row.miniappId ?? miniappId,
          title: row.title ?? '',
          status: row.status ?? 'pending',
          createdAt: row.created_at ?? row.createdAt ?? null
        };
      };

      const sortTasks = (list) =>
        list
          .filter(Boolean)
          .slice()
          .sort((a, b) => {
            const aTime = a.createdAt ? new Date(a.createdAt).getTime() : 0;
            const bTime = b.createdAt ? new Date(b.createdAt).getTime() : 0;
            if (aTime !== bTime) return aTime - bTime;
            return (a.title || '').localeCompare(b.title || '');
          });

      const getCell = (row, field) => row.querySelector(`[data-field="${field}"]`);

      function applyRowPermissions(row, enabled){
        row.querySelectorAll('[data-field]').forEach((cell) => {
          cell.contentEditable = enabled ? 'true' : 'false';
          if (!enabled) {
            cell.blur?.();
          }
        });
        const deleteBtn = row.querySelector('[data-action="delete"]');
        if (deleteBtn) {
          deleteBtn.disabled = !enabled;
        }
        row.dataset.authLocked = enabled ? 'false' : 'true';
      }

      function updateAuthNotice(enabled){
        if (!authNotice) return;
        if (!isSupabaseAvailable) {
          authNotice.hidden = true;
          authNotice.textContent = '';
          return;
        }
        if (enabled) {
          authNotice.hidden = true;
          authNotice.textContent = '';
        } else {
          authNotice.hidden = false;
          authNotice.textContent = translateKey(
            'miniapps.gestor-de-tarefas.avisoLogin',
            'Faça login para editar as tarefas.'
          );
        }
      }

      function setInteractivity(enabled){
        addBtn.disabled = !enabled;
        tbody.querySelectorAll('tr').forEach((row) => {
          applyRowPermissions(row, enabled);
        });
        updateAuthNotice(enabled);
      }

      function renderRows(){
        tbody.innerHTML = '';
        tasks.forEach((task) => {
          const row = createRow(task);
          tbody.appendChild(row);
        });
        setInteractivity(!isSupabaseAvailable || Boolean(activeSession));
      }

      function syncTasks(nextList){
        const normalized = Array.isArray(nextList) ? nextList.map(mapRow).filter(Boolean) : [];
        tasks = sortTasks(normalized);
        persistCachedTasks(miniappId, tasks);
        renderRows();
      }

      function teardownRealtime(){
        if (realtimeChannel && supabase) {
          supabase.removeChannel(realtimeChannel);
          realtimeChannel = null;
        }
      }

      function handleRealtimeChange(payload){
        if (!payload) return;
        const eventType = payload.eventType;
        if (eventType === 'DELETE') {
          const targetId = payload.old?.id;
          if (!targetId) return;
          const next = tasks.filter((item) => item.id !== targetId);
          syncTasks(next);
          MarcoBus.emit('tasks:realtime', { miniappId, eventType, id: targetId });
          return;
        }
        const mapped = mapRow(payload.new);
        if (!mapped || mapped.miniappId !== miniappId) return;
        const next = tasks.slice();
        const index = next.findIndex((item) => item.id === mapped.id);
        if (index >= 0) {
          next[index] = { ...next[index], ...mapped };
        } else {
          next.push(mapped);
        }
        syncTasks(next);
        MarcoBus.emit('tasks:realtime', { miniappId, eventType, id: mapped.id });
      }

      function ensureRealtimeSubscription(){
        if (!supabase) return;
        teardownRealtime();
        if (!activeSession) return;
        realtimeChannel = supabase
          .channel(`task_items_${miniappId}`)
          .on(
            'postgres_changes',
            {
              event: '*',
              schema: 'public',
              table: 'task_items',
              filter: `miniapp_id=eq.${miniappId}`
            },
            handleRealtimeChange
          )
          .subscribe((status) => {
            if (status === 'SUBSCRIBED') {
              MarcoBus.emit('tasks:realtime:ready', { miniappId });
            }
          });
      }

      async function refreshSession(){
        if (!supabase) {
          activeSession = null;
          setInteractivity(true);
          return null;
        }
        try {
          const { data, error } = await supabase.auth.getSession();
          if (error) {
            console.warn('[tasks] Não foi possível recuperar sessão', error);
            activeSession = null;
          } else {
            activeSession = data?.session ?? null;
          }
        } catch (error) {
          console.warn('[tasks] Falha ao obter sessão', error);
          activeSession = null;
        }
        if (activeSession) {
          ensureRealtimeSubscription();
        } else {
          teardownRealtime();
        }
        setInteractivity(!isSupabaseAvailable ? true : Boolean(activeSession));
        return activeSession;
      }

      if (supabase) {
        supabase.auth.onAuthStateChange((event, session) => {
          activeSession = session;
          setInteractivity(!isSupabaseAvailable ? true : Boolean(activeSession));
          if (event === 'SIGNED_IN' || event === 'TOKEN_REFRESHED') {
            ensureRealtimeSubscription();
            hydrateTasks();
          }
          if (event === 'SIGNED_OUT') {
            teardownRealtime();
            syncTasks([]);
          }
        });
      }

      async function hydrateTasks(){
        if (!supabase) {
          syncTasks(loadCachedTasks(miniappId));
          return;
        }
        const session = await refreshSession();
        if (!session) {
          tasks = sortTasks(loadCachedTasks(miniappId));
          renderRows();
          return;
        }
        try {
          const { data, error } = await supabase
            .from('task_items')
            .select('id,title,status,created_at,miniapp_id')
            .eq('miniapp_id', miniappId)
            .order('created_at', { ascending: true });
          if (error) {
            throw error;
          }
          const mapped = Array.isArray(data) ? data.map(mapRow).filter(Boolean) : [];
          syncTasks(mapped);
          MarcoBus.emit('tasks:sync', { miniappId, source: 'supabase', count: mapped.length });
        } catch (error) {
          console.warn('[tasks] Falha ao carregar tarefas', error);
          tasks = sortTasks(loadCachedTasks(miniappId));
          renderRows();
        }
      }

      async function persistRow(row){
        if (row.dataset.syncing === 'true') return;
        const titleCell = getCell(row, 'title');
        const statusCell = getCell(row, 'status');
        const titleValue = (titleCell?.textContent ?? '').trim();
        const statusValue = normalizeStatus(statusCell?.textContent ?? '');

        if (!titleValue) {
          const existing = tasks.find((item) => item.id === row.dataset.taskId);
          if (existing) {
            if (titleCell) titleCell.textContent = existing.title;
            if (statusCell) statusCell.textContent = existing.status;
          } else {
            row.remove();
          }
          return;
        }

        if (!supabase) {
          const existingId = row.dataset.taskId ?? `local-${Date.now()}`;
          const existingIndex = tasks.findIndex((item) => item.id === existingId);
          const createdAt = existingIndex >= 0 ? tasks[existingIndex].createdAt : new Date().toISOString();
          const payload = {
            id: existingId,
            miniappId,
            title: titleValue,
            status: statusValue,
            createdAt
          };
          row.dataset.taskId = existingId;
          row.dataset.createdAt = createdAt;
          const next = tasks.slice();
          if (existingIndex >= 0) {
            next[existingIndex] = payload;
          } else {
            next.push(payload);
          }
          row.classList.remove('u-border-danger');
          syncTasks(next);
          return;
        }

        if (!activeSession) {
          updateAuthNotice(false);
          row.classList.add('u-border-danger');
          return;
        }

        row.dataset.syncing = 'true';
        try {
          if (row.dataset.taskId) {
            const { data, error } = await supabase
              .from('task_items')
              .update({ title: titleValue, status: statusValue })
              .eq('id', row.dataset.taskId)
              .select('id,title,status,created_at,miniapp_id')
              .single();
            if (error) {
              throw error;
            }
            const mapped = mapRow(data);
            const next = tasks.slice();
            const index = next.findIndex((item) => item.id === mapped.id);
            if (index >= 0) {
              next[index] = { ...next[index], ...mapped };
            }
            row.dataset.createdAt = mapped?.createdAt ?? row.dataset.createdAt ?? new Date().toISOString();
            row.classList.remove('u-border-danger');
            syncTasks(next);
          } else {
            const { data, error } = await supabase
              .from('task_items')
              .insert({ miniapp_id: miniappId, title: titleValue, status: statusValue })
              .select('id,title,status,created_at,miniapp_id')
              .single();
            if (error) {
              throw error;
            }
            const mapped = mapRow(data);
            row.dataset.taskId = mapped.id;
            row.dataset.createdAt = mapped.createdAt ?? new Date().toISOString();
            row.classList.remove('u-border-danger');
            syncTasks([...tasks, mapped]);
          }
        } catch (error) {
          console.warn('[tasks] Falha ao sincronizar linha', error);
          row.classList.add('u-border-danger');
        } finally {
          delete row.dataset.syncing;
        }
      }

      async function removeRow(row){
        const id = row.dataset.taskId;
        if (!id) {
          row.remove();
          syncTasks(tasks.filter((item) => item.id));
          return;
        }

        if (!supabase) {
          row.remove();
          syncTasks(tasks.filter((item) => item.id !== id));
          return;
        }

        if (!activeSession) {
          updateAuthNotice(false);
          return;
        }

        try {
          const { error } = await supabase.from('task_items').delete().eq('id', id);
          if (error) {
            throw error;
          }
          row.remove();
          syncTasks(tasks.filter((item) => item.id !== id));
        } catch (error) {
          console.warn('[tasks] Falha ao remover linha', error);
        }
      }

      function createRow(task){
        const tr = document.createElement('tr');
        if (task?.id) {
          tr.dataset.taskId = task.id;
        }
        if (task?.createdAt) {
          tr.dataset.createdAt = task.createdAt;
        }

        const titleCell = document.createElement('td');
        titleCell.contentEditable = 'true';
        titleCell.dataset.field = 'title';
        titleCell.textContent = task?.title ?? '';

        const statusCell = document.createElement('td');
        statusCell.contentEditable = 'true';
        statusCell.dataset.field = 'status';
        statusCell.textContent = task?.status ?? 'pending';

        const actionsCell = document.createElement('td');
        const deleteBtn = document.createElement('button');
        deleteBtn.className = 'c-btn';
        deleteBtn.dataset.action = 'delete';
        deleteBtn.textContent = translateKey(
          'miniapps.gestor-de-tarefas.tabela.excluir',
          'Excluir'
        );
        actionsCell.appendChild(deleteBtn);

        tr.appendChild(titleCell);
        tr.appendChild(statusCell);
        tr.appendChild(actionsCell);

        const syncRow = () => { persistRow(tr); };
        titleCell.addEventListener('blur', syncRow);
        statusCell.addEventListener('blur', syncRow);
        deleteBtn.addEventListener('click', () => removeRow(tr));

        applyRowPermissions(tr, !isSupabaseAvailable || Boolean(activeSession));
        return tr;
      }

      addBtn.onclick = () => {
        if (addBtn.disabled) {
          updateAuthNotice(false);
          return;
        }
        const row = createRow({ title: '', status: 'pending' });
        tbody.prepend(row);
        const titleCell = getCell(row, 'title');
        titleCell?.focus();
      };

      await hydrateTasks();
      setInteractivity(!isSupabaseAvailable || Boolean(activeSession));
    }
  </script>
</body>
</html>
